"use strict";(self.webpackChunkrunty_website=self.webpackChunkrunty_website||[]).push([[616],{876:function(t,e,n){n.d(e,{Zo:function(){return l},kt:function(){return y}});var r=n(2784);function a(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function o(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,r)}return n}function i(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?o(Object(n),!0).forEach((function(e){a(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function u(t,e){if(null==t)return{};var n,r,a=function(t,e){if(null==t)return{};var n,r,a={},o=Object.keys(t);for(r=0;r<o.length;r++)n=o[r],e.indexOf(n)>=0||(a[n]=t[n]);return a}(t,e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);for(r=0;r<o.length;r++)n=o[r],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(a[n]=t[n])}return a}var p=r.createContext({}),s=function(t){var e=r.useContext(p),n=e;return t&&(n="function"==typeof t?t(e):i(i({},e),t)),n},l=function(t){var e=s(t.components);return r.createElement(p.Provider,{value:e},t.children)},c={inlineCode:"code",wrapper:function(t){var e=t.children;return r.createElement(r.Fragment,{},e)}},m=r.forwardRef((function(t,e){var n=t.components,a=t.mdxType,o=t.originalType,p=t.parentName,l=u(t,["components","mdxType","originalType","parentName"]),m=s(n),y=a,f=m["".concat(p,".").concat(y)]||m[y]||c[y]||o;return n?r.createElement(f,i(i({ref:e},l),{},{components:n})):r.createElement(f,i({ref:e},l))}));function y(t,e){var n=arguments,a=e&&e.mdxType;if("string"==typeof t||a){var o=n.length,i=new Array(o);i[0]=m;var u={};for(var p in e)hasOwnProperty.call(e,p)&&(u[p]=e[p]);u.originalType=t,u.mdxType="string"==typeof t?t:a,i[1]=u;for(var s=2;s<o;s++)i[s]=n[s];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},7976:function(t,e,n){n.r(e),n.d(e,{assets:function(){return p},contentTitle:function(){return i},default:function(){return c},frontMatter:function(){return o},metadata:function(){return u},toc:function(){return s}});var r=n(7896),a=(n(2784),n(876));const o={title:"Migrating from v0.1.x"},i=void 0,u={unversionedId:"migrating-from-0-1-x",id:"migrating-from-0-1-x",title:"Migrating from v0.1.x",description:"Background",source:"@site/docs/migrating-from-0-1-x.md",sourceDirName:".",slug:"/migrating-from-0-1-x",permalink:"/docs/migrating-from-0-1-x",editUrl:"https://github.com/nderscore/runty/edit/master/packages/website/docs/migrating-from-0-1-x.md",tags:[],version:"current",frontMatter:{title:"Migrating from v0.1.x"},sidebar:"sidebar",previous:{title:"TypeScript",permalink:"/docs/typescript"},next:{title:"Extending With Custom Functions",permalink:"/docs/custom-fns"}},p={},s=[{value:"Background",id:"background",level:2},{value:"Migration",id:"migration",level:2}],l={toc:s};function c(t){let{components:e,...n}=t;return(0,a.kt)("wrapper",(0,r.Z)({},l,n,{components:e,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"background"},"Background"),(0,a.kt)("p",null,"Prior to the v0.2.0 rewrite, runty used a different API for defining templates that used currying to set options. There also was only one runty function, ",(0,a.kt)("inlineCode",{parentName:"p"},"runty()"),", with no separation between string and array templates, and the ability to trigger array syntax at any level of the currying. This was too flexible to easily fit into the migration to TypeScript without negatively impacting the return types of all templates (they would always be of type ",(0,a.kt)("inlineCode",{parentName:"p"},"string | (string | unknown)[]"),") so as of v0.2.0 the API has changed to split string and array output templates and remove the options currying syntax."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"// options currying syntax:\nrunty(options)(template)(variables);\n\n// trigger array output in options:\nrunty({ asArray: true })(template)(variables);\n\n// trigger array output at template definition:\nrunty()(template, true)(variables);\n\n// trigger array output at template execution:\nrunty()(template)(variables, true);\n")),(0,a.kt)("h2",{id:"migration"},"Migration"),(0,a.kt)("p",null,"Migration to the new API should be fairly straight-forward. Just remove one layer of function calls, swap ",(0,a.kt)("inlineCode",{parentName:"p"},"runty")," for ",(0,a.kt)("inlineCode",{parentName:"p"},"runty.string"),", and move your options to the second argument where you define your template."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"// before:\nconst runt = runty(options);\nconst template = runt('...');\n\n// after:\nconst template = runty.string('...', options);\n")),(0,a.kt)("p",null,"If you were re-using an instance of runty with options, you can re-create the same behavior on your own:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"// before:\nexport const runt = runty(options);\n\n// elsewhere in the app:\nconst template = runt('...');\n\n// after:\nexport const runt = (template) => runty(template, options);\n")),(0,a.kt)("p",null,"If you were using array output, use ",(0,a.kt)("inlineCode",{parentName:"p"},"runty.array()")," or the ",(0,a.kt)("inlineCode",{parentName:"p"},"array()")," export instead."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"// before:\nexport const runt = runty({ asArray: true });\n// or:\nrunt('...', true);\n// or:\ntemplate('...', true);\n\n// after:\nconst template = runty.array('...');\n")))}c.isMDXComponent=!0}}]);